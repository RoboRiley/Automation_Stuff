## Context
I am trying to locate unique selectors for a list of items on a website.  This is for automation in software called ZeroWork.  Here is some of the ZeroWork documentation about selectors:

## Building a Selector
To build a selector, you need to adhere to this structure:
tag[attribute='value']
Note that there is no space between tag and attribute in square brackets. Note that the value is wrapped in quotes.
Or, if your element has several attributes, then the structure can be:
tag[attribute1='value'][attribute2='value']
So for Wikipedia's search button in the above example, the selector would look like this:
button[class='pure-button pure-button-primary-progressive'][type='submit']

## One Element Can Have Many Selector Expressions
A selector can be built in many different ways. You can include all attributes. You can include only one attribute or some of the attributes. You can include attributes but no value (in the rare cases where the attributes are so unique in themselves). You can add a hierarchy (you will learn what hierarchy is in one of the next sections Hierarchy). For example, the search button on Wikipedia can be expressed in many ways, and it will be addressed by any of the below:
button[class='pure-button pure-button-primary-progressive'][type='submit']
button[type='submit']
button[class='pure-button pure-button-primary-progressive']
button[class*='button'][type='submit']
button[class*='button']
button[class][type]
Will these selectors really work and address the same button? Yes! 
One element - many ways to express its corresponding CSS selector!
So which should you choose? To get an answer to this question, read on

## Adhere to Best Practices
Try to create lean, short selectors. The more attributes your selectors contain, the more prone they are to fail in case something changes on the website.
Try to not use any 'cryptic' text within the value of the attributes such as random letter combinations. Instead, try to identify unique values inside the attributes' values. A unique value is often descriptive of what the element is. If there are no descriptive values and unique attributes at all, then it might be better to only use hierarchy (more about hierarchy here: Hierarchy) and discard all attributes and values.
The more strict your hierarchy is (using many times ">" within your selector), the more prone your selector is to fail in case some element is removed from that hierarchy. If you are not sure what hierarchy is, continue reading this guide and come back to review this page at the end.

## Examples
Based on these rules, let's examine reliability of the above list of selectors. To be clear, all of the above selectors are valid and your TaskBot will run successfully with any of them. In this section, we are only evaluating how robust these selectors are over time. 

NO: button[class='pure-button pure-button-primary-progressive'][type='submit']
Why not: Other selectors are shorter. Lean, short selectors tend to be more robust

The value pure-button pure-button-primary-progressive appears more 'cryptic' and less descriptive compared to submit or button.

NO: button[class='pure-button pure-button-primary-progressive']
Why not: The value pure-button pure-button-primary-progressive appears more 'cryptic' and less descriptive compared to submit or button.

NO: button[class*='button']
Why not: This might be too generic because there can be many buttons with value button in their class attribute on a page, so we should add an additional attribute or use a different attribute altogether to make this selector more unique, if possible.

NO: button[class][type]
Why not: This might be too generic, too, because attributes type and class are very common, so we should add values to these attributes or add additional attributes.

YES: button[class*='button'][type='submit']
Why yes:
This selector uses two attributes with two concise, descriptive and well-identifiable values.

YES: button[type='submit']
Why yes:
While this selector might be a bit too generic and has some risk of not being unique, it's not common for a website to have multiple submit buttons on the same page, so this selector is a good choice, too.

## Hierarchy
Understanding hierarchy is one of the most important steps when it comes to building custom selectors. Do not skip this section!
Every web element on a website adheres to a hierarchy. See the hierarchy for the search button on the Wikipedia page.
For the search button on Wikipedia, the hierarchy would be: 
body > div > form > fieldset > button
Note that some elements are on the same level (see picture below). This means these elements are items in a list and siblings to each other. They cannot be defined in a hierarchical way as shown in the example above (with >). They can be either defined as a list (you will learn about it later in chapter Lists: Incremental CSS Selectors) or - which is a bit more advanced - as siblings (you will learn about it in the final chapter of this guide Addressing Siblings).

##Strict and Loose Hierarchy
Strict hierarchy
Whenever you use >, the hierarchy is defined in a strict way - in the example above (body > div > form > fieldset > button), body MUST be followed by div and if not the selector will fail. 
Loose hierarchy
Alternatively, you can use space to define a loose hierarchy, for example: 
body button
This means that body is followed by button somewhere below and it doesn't matter if there are other elements between body and button.

Build Selectors Based on Hierarchy
In some cases, to build a selector, you may need to additionally define the hierarchy. You can simply define tags that follow each other, like this:
Strict hierarchy: tag1 > tag2 > tag3 > tag4 > tag5
Loose hierarchy: tag1 tag3 tag5 (did you note how tag2 and tag4 are skipped?) 
Combination of strict and loose hierarchy: tag1 tag3 > tag4  (note how tag2 is skipped but tag4 strictly follows tag3)
And for any tag inside the hierarchy you can add attributes like this:
tag1[attribute='value'] > tag2[attribute='value']
tag1 > tag2[attribute='value']
tag1[attribute='value'] > tag2

For the example of the search button on Wikipedia, the list of selectors we built can be extended by these ones, and they will work just as well:
Strict hierarchy: body > div > form > fieldset > button[class*='pure-button']
Loose hierarchy: body form button[class*='pure-button']
Combination of strict and loose hierarchy: body > div button[class*='pure-button']

##You can combine ZeroWork's text= method with the standard selector logic by using >> as a filter.
As an imaginary example, you can define a selector like this:
div > div[role='main'] > div div >> text="Like"
>> can only be added at the end of the selector. 
This will work: div > div[role='main'] > div div >> text="Like"
This will not work: div > div[role='main'] > div >> text="Like" > div

##Lists: Incremental CSS Selectors
This is another very crucial section that you need to understand in order to be able to build selectors. So do not skip this one!

Selectors have incremental numbers in lists. 
For example, imagine that you want to store a complete list of hundreds of contacts from LinkedIn. In this case, the web elements (e.g., profile name, profile link, job position, etc.) inside of that list have an incremental selector. 

When Copying Selectors
Let's just copy the selectors of the profiles on LinkedIn’s search results. By copy, we mean this way of getting selectors: Copy Selectors. In this case, the selector corresponds to the contact’s profile name (first and last name):
li:nth-child(1) > div.abi-saved-contacts-row__details > button[type=”button”] > div > div > span
li:nth-child(2) > div.abi-saved-contacts-row__details > button[type=”button”] > div > div > span
As you can see, each CSS selector has a number that increments. For your convenience, we highlighted the incrementing number in red (see above).
Now imagine that you want to save the entire list of these 100 contacts. To accomplish this, refer to the example in Save Lists and How to Use Loop Index Syntax to Save Lists of Public Data.

## When Building Custom Selectors
Let's continue with the example where you want to save a list of profiles from LinkedIn. As you have already learned, all the selectors in such a list will be the same and have an incremental number (as described above).
Now, however, you want to build your own custom selector.
There are two ways of dealing with it.
Method one: Use >> nth=number
Use an addition in the form of >> nth=0 where 0 represents the incremental number, so it can be changed to nth=1, nth=2, etc., depending on which element in the list you want to address. Note that you cannot check correctness of it via document.querySelectorAll because this method is unique to ZeroWork.
Let's start with building the selector for name and surname on LinkedIn Sales Navigator (you can use LinkedIn free version instead -> you will just define a different selector compared to what you see below, but the steps are the same). 
A selector that proved robust enough is: 
a[data-anonymize='person-name']
By entering it on the console and executing document.querySelectorAll("a[data-anonymize='person-name']"), you will get 25 results which correspond to 25 profiles on the page. (You will get 10 on LinkedIn free version.) This is exactly what we are looking for - remember the selectors for the items of the list are the same, and this is why the result is not unique.
You can now use >> nth= which would look like this:
a[data-anonymize='person-name'] >> nth=0
0 corresponds to the first item in the list. (>>nth= is a zero based system, meaning that 0 corresponds to the first item, 1 corresponds to the second item, etc.). 
If you change 0 to 1, then you would be addressing the second item in this list: 
a[data-anonymize='person-name'] >> nth=1
If you want to address the whole list, you need to use {loop_index,1}, which is specific to ZeroWork application, and you can learn more about it here: #how-save-a-list-not-just-one-profile.
Method two: Use :nth-child(number)
Another way is to add an addition to the incrementing element in the form of :nth-child(1), where 1 represents the incremental number, so likewise it can be changed to :nth-child(2), :nth-child(3), etc., depending on which element in the list you want to address. 
The difference from the first method is that you need to find out which tag in the hierarchy structure increments and thus represents the list. This makes this method more difficult but also more precise.
Let's continue with the same example where the selector was this:
a[data-anonymize='person-name']
Now, your next step is to analyze the elements in the hierarchy to find out which one represent an incremental list. You may need to expand and collapse different elements to get an overview. At some point, you will see the structure shown below. You can see the incremental element with li as a tag, which corresponds to every card in the list. You can recognize it as list because all these li-tags are listed on the same level and when you hover over them, the elements in your list are highlighted.
Since the selector for name and surname is inside that element, you would need to place it after li to reflect the hierarchy. The final selector for this list would be: 
li:nth-child(1) a[data-anonymize='person-name']
1 corresponds to the first item in the list. Note that :nth-child() is not a zero based system, meaning that 1 corresponds to the first item, 2 corresponds to the second item, etc. 
If you change 1 to 2, then you would be addressing the second item in this list: 
li:nth-child(2) a[data-anonymize='person-name']
The way you can address the whole list is by using {loop_index,1} 

## TASK
Based on all the above information, please locate a selector for {{target}} from the following website code: {{elements}}